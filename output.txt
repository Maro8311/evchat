//components/ChargingStationInfo.tsx
import { ChargingStation } from '../lib/types';
import { calculateDistance } from '../lib/utils';

interface ChargingStationInfoProps {
  station: ChargingStation;
  userPosition: Position;
}

const ChargingStationInfo: React.FC<ChargingStationInfoProps> = ({
  station,
  userPosition,
}) => {
  const distance = calculateDistance(
    userPosition.coords.latitude,
    userPosition.coords.longitude,
    station.AddressInfo.Latitude,
    station.AddressInfo.Longitude
  );

  const renderAttribute = (attribute: any) => {
    if (attribute == null || attribute === '') {
      return 'N/A';
    } else {
      return attribute;
    }
  };

  return (
    <div>
      <h3>{renderAttribute(station.AddressInfo.Title)}</h3>
      <p>
        {renderAttribute(station.AddressInfo.AddressLine1)},{' '}
        {renderAttribute(station.AddressInfo.Town)},{' '}
        {renderAttribute(station.AddressInfo.StateOrProvince)},{' '}
        {renderAttribute(station.AddressInfo.Postcode)}
      </p>
      <p>Country ID: {renderAttribute(station.AddressInfo.CountryID)}</p>
      <p>
        Coordinates:{' '}
        {renderAttribute(station.AddressInfo.Latitude)},{' '}
        {renderAttribute(station.AddressInfo.Longitude)}
      </p>
      <p>Operator: {renderAttribute(station.OperatorInfo?.Title)}</p>
      <p>Distance: {distance.toFixed(2)} km</p>
      <p>Status: {station.StatusType?.IsAvailable ? 'Available' : 'Occupied'}</p>
      <p>Connectors:</p>
      <ul>
        {station.Connections.map((connection) => (
          <li key={connection.ID}>
            Plug Type: {connection.ConnectionTypeID}, Max Power: {connection.PowerKW} kW,{' '}
            Quantity: {connection.Quantity}, Pricing Info: (add pricing info if available)
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ChargingStationInfo;


//components/ConnectorFilters.tsx
import { useState, useEffect } from 'react';

interface ConnectorFiltersProps {
  onChange: (connectors: number[]) => void;
}

const ConnectorFilters: React.FC<ConnectorFiltersProps> = ({ onChange }) => {
  const [type2, setType2] = useState(true);
  const [chademo, setChademo] = useState(true);
  const [ccs, setCcs] = useState(true);

  useEffect(() => {
    const selectedConnectors = [
      ...(type2 ? [25] : []),
      ...(chademo ? [2] : []),
      ...(ccs ? [33] : []),
    ];
    console.log('Conn:', selectedConnectors.toString())
    onChange(selectedConnectors);
  }, [type2, chademo, ccs]);

  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const connectorId = parseInt(event.target.value);
    const isChecked = event.target.checked;

    if (connectorId === 25) setType2(isChecked);
    if (connectorId === 2) setChademo(isChecked);
    if (connectorId === 33) setCcs(isChecked);
  };

  return (
    <div>
      <div>
        <label>
          <input
            type="checkbox"
            value="25"
            checked={type2}
            onChange={handleCheckboxChange}
          />
          Type 2 (25)
        </label>
      </div>
      <div>
        <label>
          <input
            type="checkbox"
            value="2"
            checked={chademo}
            onChange={handleCheckboxChange}
          />
          CHAdeMO (2)
        </label>
      </div>
      <div>
        <label>
          <input
            type="checkbox"
            value="33"
            checked={ccs}
            onChange={handleCheckboxChange}
          />
          CCS (33)
        </label>
      </div>
    </div>
  );
};

export default ConnectorFilters;


//components/Map.tsx
import { MapContainer, TileLayer, ZoomControl, Marker, Popup, useMap, useMapEvent } from 'react-leaflet';
import { Icon } from 'leaflet';
import { ChargingStation } from '../lib/types';
import ChargingStationInfo from './ChargingStationInfo';

interface MapProps {
  position: GeolocationPosition;
  chargingStations: ChargingStation[];
  onPositionChange: (newPosition: GeolocationPosition) => void;
}

interface MapEventHandlerProps {
  onPositionChange: (newPosition: GeolocationPosition) => void;
}

const MapEventHandler: React.FC<MapEventHandlerProps> = ({ onPositionChange }) => {
  const map = useMap();

  const handleMouseUp = (event: L.LeafletMouseEvent) => {
    // console.log('Mouse up event:', event);

    const center = map.getCenter();
    // console.log('Map center:', center);

    // Create a new GeolocationPosition object
    const newPosition: GeolocationPosition = {
      coords: {
        latitude: center.lat,
        longitude: center.lng,
      },
      timestamp: Date.now(),
    };

    // Call the callback function with the new position
    onPositionChange(newPosition);
  };

  useMapEvent('mouseup', handleMouseUp);

  return null;
};

const Map: React.FC<MapProps> = ({ position, chargingStations, onPositionChange }) => {
  const greenIcon = new Icon({
    iconUrl:
      'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
  });

  const redIcon = new Icon({
    iconUrl:
      'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
  });

  const yellowIcon = new Icon({
    iconUrl:
      'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png',
    iconSize: [25, 41],
    iconAnchor: [12, 41],
  });

  const handleMouseUp = (event: L.LeafletMouseEvent, map: L.Map) => {
    console.log('Mouse up event:', event);

    const center = map.getCenter();
    console.log('Map center:', center);

    // Your custom logic here
  };

  return (
    <MapContainer
      center={[position.coords.latitude, position.coords.longitude]}
      zoom={13}
      zoomControl={false}
      style={{ height: '90%', width: '100%' }}
      scrollWheelZoom={false}
    >
      <MapEventHandler onPositionChange={onPositionChange} />
      <ZoomControl position="topleft" />
      <TileLayer
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
      />
      {chargingStations.map((station) => {
        const markerIcon =
          station.StatusType?.IsOperational === null
            ? yellowIcon
            : station.StatusType?.IsOperational
              ? greenIcon
              : redIcon;

        return (
          <Marker
            key={station.ID}
            position={[
              station.AddressInfo.Latitude,
              station.AddressInfo.Longitude,
            ]}
            icon={markerIcon}
          >
            <Popup>
              <ChargingStationInfo station={station} userPosition={position} />
            </Popup>
          </Marker>
        );
      })}
      {/* <ChangeView center={[position.coords.latitude, position.coords.longitude]}/>  */}
    </MapContainer>
  );
};

export default Map;


//components/RadiusInput.tsx
import { useState } from 'react';

interface RadiusInputProps {
  onChange: (radius: number) => void;
  initialRadius: number;
  setRadius: (radius: number) => void;
}

export const RadiusInput: React.FC<RadiusInputProps> = ({
  onChange,
  initialRadius,
  setRadius,
}) => {
  const [radius, setLocalRadius] = useState(initialRadius);

  const handleRadiusChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newRadius = parseInt(event.target.value);
    setLocalRadius(newRadius);
    onChange(newRadius);
    setRadius(newRadius);
  };

  return (
    <form>
      <label>
        Radius (km):
        <input type="range" min={0} max={20} value={radius} onChange={handleRadiusChange} />
        {radius} km
      </label>
    </form>
  );
};

interface MaxResultsDropdownProps {
  onChange: (maxResults: number) => void;
  initialMaxResults: number;
}

export const MaxResultsDropdown: React.FC<MaxResultsDropdownProps> = ({
  onChange,
  initialMaxResults,
}) => {
  const [maxResults, setMaxResults] = useState(initialMaxResults);

  const handleMaxResultsChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const value = parseInt(event.target.value);
    setMaxResults(value);
    onChange(value);
  };

  return (
    <label>
      Max Results:
      <select value={maxResults} onChange={handleMaxResultsChange}>
        <option value={20}>20</option>
        <option value={50}>50</option>
        <option value={100}>100</option>
        <option value={200}>200</option>
        <option value={500}>500</option>
      </select>
    </label>
  );
};

//pages/index.tsx
import { useEffect, useState } from 'react';
import ReactLoading from 'react-loading';
import dynamic from 'next/dynamic';
import { getCurrentPosition } from '../lib/geolocation';
import { getChargingStations } from '../lib/api';
import { CONNECTOR_TYPE_IDS } from '../lib/constants';
import { ChargingStation } from '../lib/types';
import ConnectorFilters from '../components/ConnectorFilters';
import { MaxResultsDropdown, RadiusInput } from '../components/RadiusInput';

const Map = dynamic(() => import('../components/Map'), { ssr: false });

export default function Home() {
  const defaultBerlinPosition: GeolocationPosition = {
    coords: {
      latitude: 52.5200,
      longitude: 13.4050,
      accuracy: 0,
      altitude: null,
      altitudeAccuracy: null,
      heading: null,
      speed: null,
    },
    timestamp: Date.now(),
  };
  
  const [position, setPosition] = useState<GeolocationPosition>(defaultBerlinPosition);
  const [chargingStations, setChargingStations] = useState<ChargingStation[]>([]);
  const [selectedConnectors, setSelectedConnectors] = useState(CONNECTOR_TYPE_IDS);
  const [maxResults, setMaxResults] = useState(100);
  const [radius, setRadius] = useState(10);
  const [loading, setLoading] = useState(false);

  const getStations = async (pos = position) => {
    return await getChargingStations(
      pos.coords.latitude,
      pos.coords.longitude,
      radius,
      maxResults,
      selectedConnectors,
    );
  }

  const getPositionAndStations = async () => {
    setLoading(true);
    try {
      const pos = await getCurrentPosition();
      setPosition(pos);
      const stations = await getStations(pos);
      setChargingStations(stations);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // console.log('useEffect')
    getPositionAndStations();
  }, [selectedConnectors, maxResults, radius]);

  const handlePositionChange = async (newPosition: GeolocationPosition) => {
    setPosition(newPosition);
    // console.log('handlePos')
    setLoading(true);
    try {
      const newStations = await getStations();
      setChargingStations(newStations);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };

  const handleConnectorFilterChange = (connectors: number[]) => {
    setSelectedConnectors(connectors);
  };

  const handleMaxResultsChange = (maxResults: number) => {
    setMaxResults(maxResults);
  };

  const handleRadiusChange = (radius: number) => {
    setRadius(radius);
  };

  return (
    <>
      <div style={{ height: '100vh', width: '100%', position: 'relative' }}>
        <div style={{
          position: 'absolute', top: '10px', left: '10px', zIndex: 1000, backgroundColor: 'white',
          padding: '10px', borderRadius: '5px',
        }}
        >
          <ConnectorFilters onChange={handleConnectorFilterChange} />
          <MaxResultsDropdown onChange={handleMaxResultsChange} initialMaxResults={maxResults} />
          <RadiusInput onChange={handleRadiusChange} initialRadius={radius} setRadius={setRadius} />
        </div>
        {loading && (
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 1001,
            }}
          >
            <ReactLoading type="spin" color="#3f51b5" />
          </div>
        )}
        <Map position={position} chargingStations={chargingStations} onPositionChange={handlePositionChange} />
      </div>
    </>
  );
}


//lib/api.ts
import { ChargingStation } from './types';

const API_BASE_URL = 'https://api.openchargemap.io/v3/poi';
const apiKey = process.env.OPENCHARGEMAP_API_KEY;

export const getChargingStations = async (
  latitude: number,
  longitude: number,
  radius: number,
  maxresults: number,
  connectorTypeIds: number[],
  useClientSideFiltering: boolean = false // Add this optional parameter with a default value of false
): Promise<ChargingStation[]> => {
  const url = new URL(API_BASE_URL);
  url.searchParams.set('output', 'json');
  url.searchParams.set('latitude', String(latitude));
  url.searchParams.set('longitude', String(longitude));
  url.searchParams.set('distanceunit', 'KM');
  url.searchParams.set('distance', String(radius));
  url.searchParams.set('countrycode', 'DE');
  url.searchParams.set('maxresults', String(maxresults));
  url.searchParams.set('compact', 'false');
  url.searchParams.set('verbose', 'true');
  if (!useClientSideFiltering) {
    url.searchParams.set('connectiontypeid', connectorTypeIds.join());
  }
  url.searchParams.set('key', apiKey);

  const response = await fetch(url.toString());
  if (!response.ok) {
    throw new Error(`Request failed with status ${response.status}`);
  }
  const data = await response.json();

  const stations = data.map((station: any) => ({
    ID: station.ID,
    Title: station.AddressInfo?.Title,
    AddressLine1: station.AddressInfo?.AddressLine1,
    Town: station.AddressInfo?.Town,
    StateOrProvince: station.AddressInfo?.StateOrProvince,
    Postcode: station.AddressInfo?.Postcode,
    Country: station.AddressInfo?.Country?.Title,
    Latitude: station.AddressInfo?.Latitude,
    Longitude: station.AddressInfo?.Longitude,
    Operator: station.OperatorInfo?.Title,
    UsageCost: station.UsageCost,
    Connections: station.Connections,
    StatusType: station.StatusType,
    UsageType: station.UsageType,
    AddressInfo: station.AddressInfo,
  })) as ChargingStation[];

  // If useClientSideFiltering is true, manually filter the charging stations based on the selected connectors
  if (useClientSideFiltering) {
    const filteredStations = stations.filter((station) =>
      station.Connections && station.Connections.some((connection) =>
        connectorTypeIds.includes(connection.ConnectionTypeID)
      )
    );
    return filteredStations;
  }

  return stations;
};


//lib/constants.ts
export const CONNECTOR_TYPE_IDS = [25, 2, 33];
export const API_URL = 'https://api.openchargemap.io/v3/poi';
export const RADIUS_INCREMENT = 5;
export const DEFAULT_RADIUS = 10;


//lib/geolocation.ts
export const getCurrentPosition = (): Promise<GeolocationPosition> => {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(resolve, reject);
  });
};

//lib/types.ts
export interface ChargingStation {
  ID?: number;
  AddressInfo?: {
    Title?: string;
    AddressLine1?: string;
    Town?: string;
    StateOrProvince?: string;
    Postcode?: string;
    CountryID?: number;
    Latitude?: number;
    Longitude?: number;
  };
  Connections?: {
    ID?: number;
    ConnectionTypeID?: number;
    LevelID?: number;
    Amps?: number;
    Voltage?: number;
    PowerKW?: number;
    CurrentTypeID?: number;
    Quantity?: number;
  }[];
  StatusType?: {
    IsOperational?: boolean;
  };
  UsageType?: {
    ID?: number;
    Title?: string;
  };
  OperatorInfo?: {
    ID?: number;
    Title?: string;
  };
  DateLastStatusUpdate?: string;
  DataQualityLevel?: number;
  DateCreated?: string;
  SubmissionStatus?: {
    IsLive?: boolean;
  };
}


//lib/utils.ts
/**
 * Calculate the great-circle distance between two geographic coordinates using the haversine formula.
 * @param lat1 Latitude of the first point.
 * @param lon1 Longitude of the first point.
 * @param lat2 Latitude of the second point.
 * @param lon2 Longitude of the second point.
 * @returns The distance between the two points in kilometers.
 */
export const calculateDistance = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number => {
  const R = 6371; // Earth's radius in km
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const distance = R * c;
  return distance;
};


