/** BEGIN: components/ConnectorFilters.tsx **/

import { useState, useEffect } from 'react';

interface ConnectorFiltersProps {
  onChange: (connectors: number[]) => void;
}

const ConnectorFilters: React.FC<ConnectorFiltersProps> = ({ onChange }) => {
  const [type2, setType2] = useState(true);
  const [chademo, setChademo] = useState(true);
  const [ccs, setCcs] = useState(true);

  useEffect(() => {
    const selectedConnectors = [
      ...(type2 ? [25] : []),
      ...(chademo ? [2] : []),
      ...(ccs ? [33] : []),
    ];
    console.log('Conn:', selectedConnectors.toString())
    onChange(selectedConnectors);
  }, [type2, chademo, ccs]);

  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const connectorId = parseInt(event.target.value);
    const isChecked = event.target.checked;

    if (connectorId === 25) setType2(isChecked);
    if (connectorId === 2) setChademo(isChecked);
    if (connectorId === 33) setCcs(isChecked);
  };

  return (
    <div>
      <div>
        <label>
          <input
            type="checkbox"
            value="25"
            checked={type2}
            onChange={handleCheckboxChange}
          />
          Type 2 (25)
        </label>
      </div>
      <div>
        <label>
          <input
            type="checkbox"
            value="2"
            checked={chademo}
            onChange={handleCheckboxChange}
          />
          CHAdeMO (2)
        </label>
      </div>
      <div>
        <label>
          <input
            type="checkbox"
            value="33"
            checked={ccs}
            onChange={handleCheckboxChange}
          />
          CCS (33)
        </label>
      </div>
    </div>
  );
};

export default ConnectorFilters;

/** END: components/ConnectorFilters.tsx **/


/** BEGIN: lib/api.ts **/

import { ChargingStation } from './types';

const API_BASE_URL = '/api/chargingStations';

export const getChargingStations = async (
  latitude: number,
  longitude: number,
  radius: number,
  maxresults: number,
  connectorTypeIds: number[],
  useClientSideFiltering: boolean = false
): Promise<ChargingStation[]> => {
  const url = new URL(API_BASE_URL, window.location.href);
  url.searchParams.set('latitude', String(latitude));
  url.searchParams.set('longitude', String(longitude));
  url.searchParams.set('radius', String(radius));
  url.searchParams.set('maxresults', String(maxresults));
  url.searchParams.set('connectorTypeIds', connectorTypeIds.join(','));
  url.searchParams.set('useClientSideFiltering', String(useClientSideFiltering));

  const response = await fetch(url.toString());
  if (!response.ok) {
    throw new Error(`Request failed with status ${response.status}`);
  }
  const data = await response.json();

  return data;
};

/** END: lib/api.ts **/


/** BEGIN: pages/index.tsx **/

import { useEffect, useState } from 'react';
import ReactLoading from 'react-loading';
import dynamic from 'next/dynamic';
import { getCurrentPosition } from '../lib/geolocation';
import { getChargingStations } from '../lib/api';
import { CONNECTOR_TYPE_IDS } from '../lib/constants';
import { ChargingStation } from '../lib/types';
import ConnectorFilters from '../components/ConnectorFilters';
import { MaxResultsDropdown, RadiusInput } from '../components/RadiusInput';

const Map = dynamic(() => import('../components/Map'), { ssr: false });

export default function Home() {
  const defaultBerlinPosition: GeolocationPosition = {
    coords: {
      latitude: 52.5200,
      longitude: 13.4050,
      accuracy: 0,
      altitude: null,
      altitudeAccuracy: null,
      heading: null,
      speed: null,
    },
    timestamp: Date.now(),
  };

  const [position, setPosition] = useState<GeolocationPosition>(defaultBerlinPosition);
  const [chargingStations, setChargingStations] = useState<ChargingStation[]>([]);
  const [selectedConnectors, setSelectedConnectors] = useState(CONNECTOR_TYPE_IDS);
  const [maxResults, setMaxResults] = useState(100);
  const [radius, setRadius] = useState(10);
  const [loading, setLoading] = useState(false);

  const getStations = async (pos = position) => {
    setLoading(true);
    try {
      const stations = await getChargingStations(
        pos.coords.latitude,
        pos.coords.longitude,
        radius,
        maxResults,
        selectedConnectors,
      );
      setChargingStations(stations);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };
  
  const getPositionAndStations = async () => {
    try {
      const pos = await getCurrentPosition();
      setPosition(pos);
      await getStations(pos);
    } catch (error) {
      console.error(error);
    }
  };
  
  useEffect(() => {
    console.log('useEffect');
  
    // Fetch the initial data only if there are no charging stations.
    if (chargingStations.length === 0) {
      getPositionAndStations();
    } else {
      // Update the data when filters are changed or the map is dragged.
      getStations();
    }
  }, [selectedConnectors, maxResults, radius]);
  
  const handlePositionChange = async (newPosition: GeolocationPosition) => {
    setPosition(newPosition);
    await getStations();
  };

  const handleConnectorFilterChange = (connectors: number[]) => {
    setSelectedConnectors(connectors);
  };

  const handleMaxResultsChange = (maxResults: number) => {
    setMaxResults(maxResults);
  };

  const handleRadiusChange = (radius: number) => {
    setRadius(radius);
  };

  return (
    <>
      <div style={{ height: '100vh', width: '100%', position: 'relative' }}>
        <div style={{
          position: 'absolute', top: '10px', left: '10px', zIndex: 1000, backgroundColor: 'white',
          padding: '10px', borderRadius: '5px',
        }}
        >
          <ConnectorFilters onChange={handleConnectorFilterChange} />
          <MaxResultsDropdown onChange={handleMaxResultsChange} initialMaxResults={maxResults} />
          <RadiusInput onChange={handleRadiusChange} initialRadius={radius} />
        </div>
        {loading && (
          <div
            style={{
              position: 'absolute',
              top: '50%',
              left: '50%',
              transform: 'translate(-50%, -50%)',
              zIndex: 1001,
            }}
          >
            <ReactLoading type="spin" color="#3f51b5" />
          </div>
        )}
        <Map position={position} chargingStations={chargingStations} onPositionChange={handlePositionChange} />
      </div>
    </>
  );
}


/** END: pages/index.tsx **/


/** BEGIN: pages\api/chargingStations.js **/

import { getChargingStations } from './chargingStationsApi';

export default async function handler(req, res) {
  const { latitude, longitude, radius, maxresults, connectorTypeIds } = req.query;

  try {
    const stations = await getChargingStations(
      latitude,
      longitude,
      radius,
      maxresults,
      connectorTypeIds.split(',').map((id) => parseInt(id))
    );
    res.status(200).json(stations);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Failed to retrieve charging stations' });
  }
}

/** END: pages\api/chargingStations.js **/


/** BEGIN: pages\api/chargingStationsApi.ts **/

import { ChargingStation } from '../../lib/types';

const API_BASE_URL = 'https://api.openchargemap.io/v3/poi';
const apiKey = process.env.OPENCHARGEMAP_API_KEY;

export const getChargingStations = async (
  latitude: number,
  longitude: number,
  radius: number,
  maxresults: number,
  connectorTypeIds: number[],
  useClientSideFiltering: boolean = false
): Promise<ChargingStation[]> => {
  const url = new URL(API_BASE_URL);
  url.searchParams.set('output', 'json');
  url.searchParams.set('latitude', String(latitude));
  url.searchParams.set('longitude', String(longitude));
  url.searchParams.set('distanceunit', 'KM');
  url.searchParams.set('distance', String(radius));
  url.searchParams.set('countrycode', 'DE');
  url.searchParams.set('maxresults', String(maxresults));
  url.searchParams.set('compact', 'false');
  url.searchParams.set('verbose', 'true');
  if (!useClientSideFiltering) {
    url.searchParams.set('connectiontypeid', connectorTypeIds.join());
  }
  if (apiKey) {
    url.searchParams.set('key', apiKey);
  } else {
    throw new Error('API key is not defined');
  }

  const response = await fetch(url.toString());
  if (!response.ok) {
    throw new Error(`Request failed with status ${response.status}`);
  }
  const data = await response.json();

  const stations = data.map((station: any) => ({
    ID: station.ID,
    Title: station.AddressInfo?.Title,
    AddressLine1: station.AddressInfo?.AddressLine1,
    Town: station.AddressInfo?.Town,
    StateOrProvince: station.AddressInfo?.StateOrProvince,
    Postcode: station.AddressInfo?.Postcode,
    Country: station.AddressInfo?.Country?.Title,
    Latitude: station.AddressInfo?.Latitude,
    Longitude: station.AddressInfo?.Longitude,
    Operator: station.OperatorInfo?.Title,
    UsageCost: station.UsageCost,
    Connections: station.Connections,
    StatusType: station.StatusType,
    UsageType: station.UsageType,
    AddressInfo: station.AddressInfo,
  })) as ChargingStation[];

  if (useClientSideFiltering) {
    const filteredStations = stations.filter((station) =>
      station.Connections && station.Connections.some((connection) =>
        connection.ConnectionTypeID !== undefined && connectorTypeIds.includes(connection.ConnectionTypeID)
      )
    );
    return filteredStations;
  }

  return stations;
};

/** END: pages\api/chargingStationsApi.ts **/


